{"version":3,"sources":["components/Node/Node.jsx","algorithms/dijkstra.js","algorithms/breadthFirstSearch.js","algorithms/depthFisrtSearch.js","components/PathfindingVisualizer/PathfindingVisualizer.jsx","App.js","serviceWorker.js","index.js"],"names":["Node","React","forwardRef","props","ref","row","col","isFinish","isStart","isWall","weight","extraClassName","id","className","draggable","getClosestNode","nodes","closestIndex","i","length","distance","temp","pop","getNeighbors","closestNode","grid","nodesToVisit","node","previousNode","seen","push","PathfindingVisualizer","useState","getInitialGrid","mouseIsPressed","wIsPressed","state","setState","useEffect","handleMouseDown","e","preventDefault","target","startsWith","parts","split","s","getNewGridWithWeightToggled","parseInt","getNewGridWithWallToggled","document","addEventListener","handleMouseUp","handleKeyDown","isComposing","keyCode","code","handleKeyUp","handleMouseEnter","removeEventListener","onClick","startNode","endNode","animateSearch","visitedNodes","dijkstra","queue","shift","breadthFirstSearch","depthFirstSearch","map","current","Infinity","rowIdx","key","colIdx","currentRow","createNode","createRef","newGrid","slice","newNode","visitedNodesInOrder","setTimeout","n","animatePath","App","Boolean","window","location","hostname","match","ReactDOM","render","getElementById","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"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","file":"static/js/main.0efc7322.chunk.js","sourcesContent":["import React from 'react';\r\n\r\nimport './Node.css';\r\n\r\nexport const Node = React.forwardRef((props, ref) => {\r\n  const {\r\n    row,\r\n    col,\r\n    isFinish,\r\n    isStart,\r\n    isWall,\r\n    weight\r\n  } = props;\r\n  const extraClassName = isFinish ? 'node-finish' : isStart ? 'node-start' : isWall ? 'node-wall' : weight > 1 ? 'node-weight' : '';\r\n  return (\r\n    <div\r\n      id={`node-${row}-${col}`}\r\n      className={`node ${extraClassName}`}\r\n      ref={ref}\r\n      draggable=\"false\"></div>\r\n  );\r\n})","/**\r\n * An implementation of Dijkstra's algorithm that returns a list of all visited nodes in the\r\n * order in which they were visited. The nodes contain a pointer to the previous node that\r\n * can be used to construct the shortest path between the node and the start.\r\n * \r\n * @param {*} grid A 2d array of nodes representing the search area.\r\n * @param {*} startNode The starting node for the search.\r\n * @param {*} endNode The node to seach for.\r\n */\r\nexport function dijkstra(grid, startNode, endNode) {\r\n    let nodesToVisit = [startNode];\r\n    let visitedNodes = []\r\n    startNode.distance = 0;\r\n    startNode.seen = true;\r\n    while (nodesToVisit.length > 0) {\r\n        let closestNode = getClosestNode(nodesToVisit);\r\n        \r\n        visitedNodes.push(closestNode);\r\n\r\n        if (closestNode === endNode) {\r\n            return visitedNodes;\r\n        }\r\n\r\n        getNeighbors(closestNode, grid, nodesToVisit);\r\n    }\r\n    return visitedNodes;\r\n}\r\n\r\n/**\r\n * Removes and returns the node with the smallest distance. If there is more than one\r\n * node with the same smallest distance then the one with the smaller index is removed\r\n * and returned.\r\n * \r\n * @param {*} nodes A list of unvisited nodes.\r\n */\r\nfunction getClosestNode(nodes) {\r\n    let closestIndex = 0;\r\n    for (let i = 1; i < nodes.length; i++) {\r\n        if (nodes[closestIndex].distance > nodes[i].distance) {\r\n            closestIndex = i;\r\n        }\r\n    }\r\n\r\n    if (closestIndex !== nodes.length - 1) {\r\n        let temp = nodes[closestIndex];\r\n        nodes[closestIndex] = nodes[nodes.length - 1];\r\n        nodes[nodes.length - 1] = temp;\r\n    }\r\n\r\n    return nodes.pop();\r\n}\r\n\r\n/**\r\n * Updates the distance from the start of the four nodes that share and edge with the closestNode.\r\n * Any encountered node that is not a wall and has not yet been added to nodesToVisit list will be\r\n * added to the list.\r\n * \r\n * @param {*} closestNode The node to expand.\r\n * @param {*} grid The grid of nodes representing the search area.\r\n * @param {*} nodesToVisit The list of nodes unvisited nodes.\r\n */\r\nfunction getNeighbors(closestNode, grid, nodesToVisit) {\r\n    let { row, col, distance } = closestNode;\r\n\r\n    if (row > 0) {\r\n        let node = grid[row-1][col];\r\n        if (node.distance > distance + node.weight) {\r\n            node.distance = distance + node.weight;\r\n            node.previousNode = closestNode;\r\n        }\r\n        if (!node.seen && !node.isWall) {\r\n            node.seen = true;\r\n            nodesToVisit.push(node);\r\n        }\r\n    }\r\n\r\n    if (row < grid.length - 1) {\r\n        let node = grid[row+1][col];\r\n        if (node.distance > distance + node.weight) {\r\n            node.distance = distance + node.weight;\r\n            node.previousNode = closestNode;\r\n        }\r\n        if (!node.seen && !node.isWall) {\r\n            node.seen = true;\r\n            nodesToVisit.push(node);\r\n        }\r\n    }\r\n\r\n    if (col > 0) {\r\n        let node = grid[row][col - 1];\r\n        if (node.distance > distance + node.weight) {\r\n            node.distance = distance + node.weight;\r\n            node.previousNode = closestNode;\r\n        }\r\n        if (!node.seen && !node.isWall) {\r\n            node.seen = true;\r\n            nodesToVisit.push(node);\r\n        }\r\n    }\r\n\r\n    if (col < grid[row].length - 1) {\r\n        let node = grid[row][col+1];\r\n        \r\n        if (node.distance > distance + node.weight) {\r\n            node.distance = distance + node.weight;\r\n            node.previousNode = closestNode;\r\n        }\r\n        if (!node.seen && !node.isWall) {\r\n            node.seen = true;\r\n            nodesToVisit.push(node);\r\n        }\r\n    }\r\n}","/**\r\n * An implementation of the breadth first search algorithm that returns a list of all visited \r\n * nodes in the order in which they were visited. The nodes contain a pointer to the previous \r\n * node that can be used to construct the shortest path between the node and the start.\r\n * \r\n * @param {*} grid A 2d array of nodes representing the search area.\r\n * @param {*} startNode The starting node for the search.\r\n * @param {*} endNode The node to seach for.\r\n */\r\nexport function breadthFirstSearch(grid, startNode, endNode) {\r\n  let queue = [startNode];\r\n  let visitedNodes = [];\r\n  startNode.seen = true;\r\n\r\n  while (queue.length > 0) {\r\n    const node = queue.shift();\r\n    visitedNodes.push(node);\r\n\r\n    if (node === endNode) {\r\n      return visitedNodes;\r\n    }\r\n\r\n    getNeighbors(node, grid, queue);\r\n  }\r\n  return visitedNodes;\r\n}\r\n\r\n\r\n/**\r\n * Adds any of the four nodes that share an edge with the closestNode that are not walls and have not\r\n * yet been seen to the list of nodesToVisit.\r\n * \r\n * @param {*} closestNode The node to expand.\r\n * @param {*} grid The grid of nodes representing the search area.\r\n * @param {*} nodesToVisit The list of nodes unvisited nodes.\r\n */\r\nfunction getNeighbors(closestNode, grid, nodesToVisit) {\r\n  let { row, col } = closestNode;\r\n\r\n  if (row > 0) {\r\n    let node = grid[row - 1][col];\r\n    if (!node.seen && !node.isWall) {\r\n      node.seen = true;\r\n      node.previousNode = closestNode;\r\n      nodesToVisit.push(node);\r\n    }\r\n  }\r\n\r\n  if (row < grid.length - 1) {\r\n    let node = grid[row + 1][col];\r\n    if (!node.seen && !node.isWall) {\r\n      node.seen = true;\r\n      node.previousNode = closestNode;\r\n      nodesToVisit.push(node);\r\n    }\r\n  }\r\n\r\n  if (col > 0) {\r\n    let node = grid[row][col - 1];\r\n    if (!node.seen && !node.isWall) {\r\n      node.seen = true;\r\n      node.previousNode = closestNode;\r\n      nodesToVisit.push(node);\r\n    }\r\n  }\r\n\r\n  if (col < grid[row].length - 1) {\r\n    let node = grid[row][col + 1];\r\n    if (!node.seen && !node.isWall) {\r\n      node.seen = true;\r\n      node.previousNode = closestNode;\r\n      nodesToVisit.push(node);\r\n    }\r\n  }\r\n}","/**\r\n * An implementation of the depth first search algorithm that returns a list of all visited \r\n * nodes in the order in which they were visited. The nodes contain a pointer to the previous \r\n * node that can be used to construct the shortest path between the node and the start.\r\n * \r\n * @param {*} grid A 2d array of nodes representing the search area.\r\n * @param {*} startNode The starting node for the search.\r\n * @param {*} endNode The node to seach for.\r\n */\r\nexport function depthFirstSearch(grid, startNode, endNode) {\r\n  let queue = [startNode];\r\n  let visitedNodes = [];\r\n  startNode.seen = true;\r\n\r\n  while (queue.length > 0) {\r\n    const node = queue.pop();\r\n    visitedNodes.push(node);\r\n\r\n    if (node === endNode) {\r\n      return visitedNodes;\r\n    }\r\n\r\n    getNeighbors(node, grid, queue);\r\n  }\r\n  return visitedNodes;\r\n}\r\n\r\n\r\n/**\r\n * Adds any of the four nodes that share an edge with the closestNode that are not walls and have not\r\n * yet been seen to the list of nodesToVisit.\r\n * \r\n * @param {*} closestNode The node to expand.\r\n * @param {*} grid The grid of nodes representing the search area.\r\n * @param {*} nodesToVisit The list of nodes unvisited nodes.\r\n */\r\nfunction getNeighbors(closestNode, grid, nodesToVisit) {\r\n  let { row, col } = closestNode;\r\n\r\n  if (row > 0) {\r\n    let node = grid[row - 1][col];\r\n    if (!node.seen && !node.isWall) {\r\n      node.seen = true;\r\n      node.previousNode = closestNode;\r\n      nodesToVisit.push(node);\r\n    }\r\n  }\r\n\r\n  if (row < grid.length - 1) {\r\n    let node = grid[row + 1][col];\r\n    if (!node.seen && !node.isWall) {\r\n      node.seen = true;\r\n      node.previousNode = closestNode;\r\n      nodesToVisit.push(node);\r\n    }\r\n  }\r\n\r\n  if (col > 0) {\r\n    let node = grid[row][col - 1];\r\n    if (!node.seen && !node.isWall) {\r\n      node.seen = true;\r\n      node.previousNode = closestNode;\r\n      nodesToVisit.push(node);\r\n    }\r\n  }\r\n\r\n  if (col < grid[row].length - 1) {\r\n    let node = grid[row][col + 1];\r\n    if (!node.seen && !node.isWall) {\r\n      node.seen = true;\r\n      node.previousNode = closestNode;\r\n      nodesToVisit.push(node);\r\n    }\r\n  }\r\n}","import React, { useEffect, useState } from 'react';\r\nimport { Node } from '../Node/Node';\r\nimport { dijkstra } from '../../algorithms/dijkstra';\r\n\r\nimport './PathfindingVisualizer.css';\r\nimport { breadthFirstSearch } from '../../algorithms/breadthFirstSearch';\r\nimport { depthFirstSearch } from '../../algorithms/depthFisrtSearch';\r\n\r\nconst START_NODE_ROW = 10;\r\nconst START_NODE_COL = 15;\r\nconst FINISH_NODE_ROW = 10;\r\nconst FINISH_NODE_COL = 35;\r\n\r\n\r\nexport default function PathfindingVisualizer(props) {\r\n  const [state, setState] = useState({\r\n    grid: getInitialGrid(),\r\n    mouseIsPressed: false,\r\n    wIsPressed: false\r\n  });\r\n\r\n  useEffect(() => {\r\n    const handleMouseDown = (e) => {\r\n      e.preventDefault();\r\n      if (e.target.id.startsWith('node')) {\r\n        let parts = e.target.id.split('-');\r\n        setState(s => \r\n          s.wIsPressed ? {\r\n            ...s,\r\n            grid: getNewGridWithWeightToggled(s.grid, parseInt(parts[1]), parseInt(parts[2])),\r\n            mouseIsPressed: true\r\n          } : {\r\n            ...s,\r\n            grid: getNewGridWithWallToggled(s.grid, parseInt(parts[1]), parseInt(parts[2])),\r\n            mouseIsPressed: true\r\n          }\r\n        );\r\n      } else {\r\n        setState(s => ({\r\n          ...s,\r\n          mouseIsPressed: true\r\n        }));\r\n      }\r\n    }\r\n    document.addEventListener('mousedown', handleMouseDown);\r\n\r\n    const handleMouseUp = () => {\r\n      setState(s => ({\r\n        ...s,\r\n        mouseIsPressed: false\r\n      }));\r\n    }\r\n    document.addEventListener('mouseup', handleMouseUp);\r\n\r\n    const handleKeyDown = (e) => {\r\n      if (e.isComposing || e.keyCode === 229) return;\r\n      \r\n      if (e.code === 'KeyW') {\r\n        setState(s => s.wIsPressed ? s : ({\r\n          ...s,\r\n          wIsPressed: true\r\n        }));\r\n      }\r\n    }\r\n    document.addEventListener('keydown', handleKeyDown);\r\n\r\n    const handleKeyUp = (e) => {\r\n      if (e.isComposing || e.keyCode === 229) return;\r\n\r\n      if (e.code === 'KeyW') {\r\n        setState(s => ({\r\n          ...s,\r\n          wIsPressed: false\r\n        }));\r\n      }\r\n    }\r\n    document.addEventListener('keyup', handleKeyUp);\r\n\r\n    const handleMouseEnter = (e) => {\r\n      setState(s => {\r\n        if (s.mouseIsPressed && e.target.id.startsWith('node')) {\r\n          let parts = e.target.id.split('-');\r\n          return s.wIsPressed ? {\r\n            ...s,\r\n            grid: getNewGridWithWeightToggled(s.grid, parseInt(parts[1]), parseInt(parts[2])),\r\n          } : {\r\n            ...s,\r\n            grid: getNewGridWithWallToggled(s.grid, parseInt(parts[1]), parseInt(parts[2])),\r\n          };\r\n        } else {\r\n          return s;\r\n        }\r\n      })\r\n    }\r\n    document.addEventListener('mouseenter', handleMouseEnter, true);\r\n\r\n    return () => {\r\n      document.removeEventListener('mousedown', handleMouseDown);\r\n      document.removeEventListener('mouseup', handleMouseUp);\r\n      document.removeEventListener('keydown', handleKeyDown);\r\n      document.removeEventListener('keyup', handleKeyUp);\r\n      document.removeEventListener('mouseenter', handleMouseEnter);\r\n    }\r\n  }, []);\r\n\r\n  return (\r\n    <>\r\n      <nav className=\"navbar\">\r\n        <button onClick={() =>\r\n          visualizeDijkstra(state.grid, state.grid[START_NODE_ROW][START_NODE_COL], state.grid[FINISH_NODE_ROW][FINISH_NODE_COL])\r\n        }>Visualize Dijkstra's Algorithm</button>\r\n        <button onClick={() =>\r\n          visualizeBreadthFirstSearch(state.grid, state.grid[START_NODE_ROW][START_NODE_COL], state.grid[FINISH_NODE_ROW][FINISH_NODE_COL])\r\n        }>Visualize BFS Algorithm</button>\r\n        <button onClick={() =>\r\n          visualizeDepthFirstSearch(state.grid, state.grid[START_NODE_ROW][START_NODE_COL], state.grid[FINISH_NODE_ROW][FINISH_NODE_COL])\r\n        }>Visualize DFS Algorithm</button>\r\n        <button onClick={() => setState({\r\n          ...state,\r\n          grid: clearGrid(state.grid)\r\n        })}>Clear Board</button>\r\n      </nav>\r\n      <p>\r\n        Use the mouse to toggle walls. Hold down the w key and use the mouse to add/remove weight to the nodes.\r\n      </p>\r\n      <div className=\"grid\">\r\n        {state.grid.map((row, rowIdx) => {\r\n          return (\r\n            <div key={rowIdx}>\r\n              {row.map((node, colIdx) => {\r\n                const { row, col, isFinish, isStart, isWall, ref, weight } = node;\r\n                return (\r\n                  <Node\r\n                    ref={ref}\r\n                    row={row}\r\n                    col={col}\r\n                    key={colIdx}\r\n                    isFinish={isFinish}\r\n                    isStart={isStart}\r\n                    isWall={isWall}\r\n                    weight={weight} />\r\n                );\r\n              })}\r\n            </div>\r\n          );\r\n        })}\r\n      </div>\r\n    </>\r\n  );\r\n}\r\n\r\n/**\r\n * Create and return the initial grid of nodes.\r\n */\r\nfunction getInitialGrid() {\r\n  const grid = [];\r\n  for (let row = 0; row < 20; row++) {\r\n    const currentRow = [];\r\n    for (let col = 0; col < 50; col++) {\r\n      currentRow.push(createNode(row, col));\r\n    }\r\n    grid.push(currentRow);\r\n  }\r\n  return grid;\r\n}\r\n\r\n/**\r\n * Return a new grid reset to its initial state.\r\n * \r\n * @param {*} grid The current grid.\r\n */\r\nfunction clearGrid(grid) {\r\n  return grid.map(row => \r\n    row.map(node => {\r\n      const { isFinish, isStart } = node;\r\n      const extraClassName = isFinish ? 'node-finish' : isStart ? 'node-start' : '';\r\n      node.ref.current.className = `node ${extraClassName}`;\r\n      return {\r\n        ...node,\r\n        isWall: false,\r\n        weight: 1,\r\n        seen: false,\r\n        distance: Infinity,\r\n        previousNode: null\r\n      }\r\n    }));\r\n}\r\n\r\n/**\r\n * Create and return a new node that is to be located at the specified row and column.\r\n * \r\n * @param {*} row The 0 based index of row the node will be located at.\r\n * @param {*} col The 0 based index of the column the node will be located at.\r\n */\r\nfunction createNode(row, col) {\r\n  const ref = React.createRef();\r\n  return {\r\n    row,\r\n    col,\r\n    ref,\r\n    isStart: row === START_NODE_ROW && col === START_NODE_COL,\r\n    isFinish: row === FINISH_NODE_ROW && col === FINISH_NODE_COL,\r\n    distance: Infinity,\r\n    weight: 1,\r\n    seen: false,\r\n    isWall: false,\r\n    previousNode: null\r\n  }\r\n}\r\n\r\n/**\r\n * Returns a new grid with state of the node at the specified row and column\r\n * being changed so the it is a wall only if it is not currently a wall.\r\n * \r\n * @param {*} grid The current grid of nodes.\r\n * @param {*} row The row of the node to toggle.\r\n * @param {*} col The column of the node to toggle.\r\n */\r\nfunction getNewGridWithWallToggled(grid, row, col) {\r\n  if (grid[row][col].isStart || grid[row][col].isFinish) {\r\n    return grid;\r\n  }\r\n  const newGrid = grid.slice();\r\n  const node = newGrid[row][col];\r\n  const newNode = {\r\n    ...node,\r\n    isWall: !node.isWall,\r\n  };\r\n  newGrid[row][col] = newNode;\r\n  return newGrid;\r\n}\r\n\r\n/**\r\n * Returns a new grid with the node at the specified row and column\r\n * having its weight changed from 1 to 10 or 10 to 1.\r\n * \r\n * @param {*} grid The current grid of nodes.\r\n * @param {*} row The row of the node to change.\r\n * @param {*} col The column of the node to change.\r\n */\r\nfunction getNewGridWithWeightToggled(grid, row, col) {\r\n  const newGrid = grid.slice();\r\n  const node = newGrid[row][col];\r\n  const newNode = {\r\n    ...node,\r\n    weight: node.weight ^ 11,\r\n  };\r\n  newGrid[row][col] = newNode;\r\n  return newGrid;\r\n}\r\n\r\nfunction visualizeDijkstra(grid, startNode, endNode) {\r\n  const visitedNodesInOrder = dijkstra(grid, startNode, endNode);\r\n  animateSearch(visitedNodesInOrder, endNode);\r\n}\r\n\r\nfunction visualizeBreadthFirstSearch(grid, startNode, endNode) {\r\n  const visitedNodesInOrder = breadthFirstSearch(grid, startNode, endNode);\r\n  animateSearch(visitedNodesInOrder, endNode);\r\n}\r\n\r\nfunction visualizeDepthFirstSearch(grid, startNode, endNode) {\r\n  const visitedNodesInOrder = depthFirstSearch(grid, startNode, endNode);\r\n  animateSearch(visitedNodesInOrder, endNode);\r\n}\r\n\r\n/**\r\n * Causes the animation of the search to run.\r\n * \r\n * @param {*} visitedNodesInOrder The list of nodes in the order the search algorithm visited them.\r\n * @param {*} endNode The node the search algorithm was looking for.\r\n */\r\nfunction animateSearch(visitedNodesInOrder, endNode) {\r\n  for (let i = 1; i < visitedNodesInOrder.length; i++) {\r\n    if (i === visitedNodesInOrder.length - 1 && visitedNodesInOrder[i] === endNode) {\r\n      setTimeout(() => animatePath(endNode.previousNode), 10 * i);\r\n    } else {\r\n      setTimeout(() => {\r\n        const node = visitedNodesInOrder[i];\r\n        node.ref.current.className = 'node node-visited';\r\n      }, 10 * i);\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * Causes the animation of the path found by the search algorithm to run.\r\n * \r\n * @param {*} node The last node in the path.\r\n */\r\nfunction animatePath(node) {\r\n  let i = 0;\r\n  while (node !== null && node.previousNode !== null) {\r\n    setTimeout(((n) => {\r\n      return () => {\r\n        n.ref.current.className = 'node node-shortest-path';\r\n      }\r\n    })(node), 50 * i);\r\n    node = node.previousNode;\r\n    i++;\r\n  }\r\n}","import React from 'react';\nimport PathfindingVisualizer from './components/PathfindingVisualizer/PathfindingVisualizer';\nimport './App.css';\n\nfunction App() {\n  return (\n    <div className=\"App\">\n      <PathfindingVisualizer />\n    </div>\n  );\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' }\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}